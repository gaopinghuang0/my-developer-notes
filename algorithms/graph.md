
## Graph algorithms (Dijkstra, ...)
* Tarjan's algorithm to find [Strongly Connected Components](https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/), [articulation point](https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/), [bridge](https://www.geeksforgeeks.org/bridge-in-a-graph/), biconnected component. Note that in the implementation, suppose we are currently at node u, if a node v is not visited, then `low[u] = min(low[u], low[v])`; however, if node v is visited, then `low[u] = min(low[u], disc[v])`. Note, in the latter part, we must use `disc[v]`, not `low[v]`. Here is an example to explain why using `low[v]` is wrong. Suppose nodes [1,2,3,4] form a cycle and node 1 is visited first. If `low[v]` is used, then all nodes have the same `low` value (i.e., low[4] = low[3] = low[2] = low[1]). Suppose nodes [4,5,6] form another cycle. Then all nodes [4,5,6] will also have low[5] = low[6] = low[4] = low[1]. In such case, **there will be no articulation point**. However, if using `disc[v]`, then low[5] = low[6] = desc[4], which is different from low[1].
* [Strongly connected component (Kosaraju's algorithm)](https://www.geeksforgeeks.org/strongly-connected-components).
* Create an empty Stack `'S'` and do DFS on the graph. Push a vertex to stack after visiting all its neighbors. The vertices in the `'S'` are sorted by their finish time.  Essentially, this is a topological sort.
    * Create a reverse graph.
    * Pop vertex from `'S'` one by one and do DFS on the reversed graph. Save into `who[u]` array. The vertices in one SCC will have the same `who[u]`. The key is that DFS on the top of stack `'S'` is always starting from the sink of the reversed graph. After visiting all nodes of one SCC, the top of stack is the new sink.
