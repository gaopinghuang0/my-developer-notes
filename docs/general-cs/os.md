
## 内存管理
* [20 张图揭开内存管理的迷雾！](https://mp.weixin.qq.com/s/4FF5uH0YVTAM9-llKTAWKA)
  * 虚拟内存的目的是为了在多进程环境中，每个进程之间的内存地址不受影响。否则，大家都直接去访问物理地址，就会导致错误和安全问题。
  * 当很多进程存在时，物理内存吃紧。所以操作系统会做**内存交换**，把不常用的内存暂时放到硬盘里 (swap out)，在需要时重新放回物理内存 (swap in).
  * 从虚拟地址到物理地址的映射有两种方法：*分段 (segmentation)* 和 *分页 （paging）*
  * 首先是*分段*，一个进程包括代码段、数据段、堆、栈等。使用 *segment* 和 *offset* 就能确定物理地址。但是，会导致两个问题：
    * 内存碎片。一个进程的物理地址不连续。可以将某些进程的内存暂时放回硬盘里（swap out），拷贝回物理内存时，放到另一个位置，腾出连续的空间。
    * 内存交换的效率低。因为硬盘速度太慢，拷贝整个进程的内存太浪费时间。
  * 所以引入了*分页*，把虚拟内存和物理内存分成大小固定的页，比如Linux中的4KB。这样避免了细小的内存碎片，同时*内存交换*时，只需要与硬盘交换一个或几个页，大大提高了效率。
  * 但是，需要消耗大量内存来存储页表，所以引入了*多级页表*。它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的*局部性原理*，在 CPU 芯片中加入了 TLB （Translation Lookaside Buffer），负责缓存最近常被访问的页表项，大大提高了地址的转换速度。
  * 分段和分页是可以结合的。
  * Linux系统主要采用了分页管理。但由于 Intel 处理器的发展史，Linux 系统无法避免分段管理。于是 Linux 就把所有段的基地址设为 0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。另外，Linxu 系统中虚拟空间分布可分为*用户态*和*内核态*两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。